// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/0xJacky/Nginx-UI/model"
)

func newNginxLogIndex(db *gorm.DB, opts ...gen.DOOption) nginxLogIndex {
	_nginxLogIndex := nginxLogIndex{}

	_nginxLogIndex.nginxLogIndexDo.UseDB(db, opts...)
	_nginxLogIndex.nginxLogIndexDo.UseModel(&model.NginxLogIndex{})

	tableName := _nginxLogIndex.nginxLogIndexDo.TableName()
	_nginxLogIndex.ALL = field.NewAsterisk(tableName)
	_nginxLogIndex.ID = field.NewField(tableName, "id")
	_nginxLogIndex.CreatedAt = field.NewTime(tableName, "created_at")
	_nginxLogIndex.UpdatedAt = field.NewTime(tableName, "updated_at")
	_nginxLogIndex.Path = field.NewString(tableName, "path")
	_nginxLogIndex.MainLogPath = field.NewString(tableName, "main_log_path")
	_nginxLogIndex.LastModified = field.NewTime(tableName, "last_modified")
	_nginxLogIndex.LastSize = field.NewInt64(tableName, "last_size")
	_nginxLogIndex.LastPosition = field.NewInt64(tableName, "last_position")
	_nginxLogIndex.LastIndexed = field.NewTime(tableName, "last_indexed")
	_nginxLogIndex.IndexStartTime = field.NewTime(tableName, "index_start_time")
	_nginxLogIndex.IndexDuration = field.NewInt64(tableName, "index_duration")
	_nginxLogIndex.TimeRangeStart = field.NewTime(tableName, "time_range_start")
	_nginxLogIndex.TimeRangeEnd = field.NewTime(tableName, "time_range_end")
	_nginxLogIndex.DocumentCount = field.NewUint64(tableName, "document_count")
	_nginxLogIndex.Enabled = field.NewBool(tableName, "enabled")
	_nginxLogIndex.IndexStatus = field.NewString(tableName, "index_status")
	_nginxLogIndex.ErrorMessage = field.NewString(tableName, "error_message")
	_nginxLogIndex.ErrorTime = field.NewTime(tableName, "error_time")
	_nginxLogIndex.RetryCount = field.NewInt(tableName, "retry_count")
	_nginxLogIndex.QueuePosition = field.NewInt(tableName, "queue_position")

	_nginxLogIndex.fillFieldMap()

	return _nginxLogIndex
}

type nginxLogIndex struct {
	nginxLogIndexDo

	ALL            field.Asterisk
	ID             field.Field
	CreatedAt      field.Time
	UpdatedAt      field.Time
	Path           field.String
	MainLogPath    field.String
	LastModified   field.Time
	LastSize       field.Int64
	LastPosition   field.Int64
	LastIndexed    field.Time
	IndexStartTime field.Time
	IndexDuration  field.Int64
	TimeRangeStart field.Time
	TimeRangeEnd   field.Time
	DocumentCount  field.Uint64
	Enabled        field.Bool
	IndexStatus    field.String
	ErrorMessage   field.String
	ErrorTime      field.Time
	RetryCount     field.Int
	QueuePosition  field.Int

	fieldMap map[string]field.Expr
}

func (n nginxLogIndex) Table(newTableName string) *nginxLogIndex {
	n.nginxLogIndexDo.UseTable(newTableName)
	return n.updateTableName(newTableName)
}

func (n nginxLogIndex) As(alias string) *nginxLogIndex {
	n.nginxLogIndexDo.DO = *(n.nginxLogIndexDo.As(alias).(*gen.DO))
	return n.updateTableName(alias)
}

func (n *nginxLogIndex) updateTableName(table string) *nginxLogIndex {
	n.ALL = field.NewAsterisk(table)
	n.ID = field.NewField(table, "id")
	n.CreatedAt = field.NewTime(table, "created_at")
	n.UpdatedAt = field.NewTime(table, "updated_at")
	n.Path = field.NewString(table, "path")
	n.MainLogPath = field.NewString(table, "main_log_path")
	n.LastModified = field.NewTime(table, "last_modified")
	n.LastSize = field.NewInt64(table, "last_size")
	n.LastPosition = field.NewInt64(table, "last_position")
	n.LastIndexed = field.NewTime(table, "last_indexed")
	n.IndexStartTime = field.NewTime(table, "index_start_time")
	n.IndexDuration = field.NewInt64(table, "index_duration")
	n.TimeRangeStart = field.NewTime(table, "time_range_start")
	n.TimeRangeEnd = field.NewTime(table, "time_range_end")
	n.DocumentCount = field.NewUint64(table, "document_count")
	n.Enabled = field.NewBool(table, "enabled")
	n.IndexStatus = field.NewString(table, "index_status")
	n.ErrorMessage = field.NewString(table, "error_message")
	n.ErrorTime = field.NewTime(table, "error_time")
	n.RetryCount = field.NewInt(table, "retry_count")
	n.QueuePosition = field.NewInt(table, "queue_position")

	n.fillFieldMap()

	return n
}

func (n *nginxLogIndex) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := n.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (n *nginxLogIndex) fillFieldMap() {
	n.fieldMap = make(map[string]field.Expr, 20)
	n.fieldMap["id"] = n.ID
	n.fieldMap["created_at"] = n.CreatedAt
	n.fieldMap["updated_at"] = n.UpdatedAt
	n.fieldMap["path"] = n.Path
	n.fieldMap["main_log_path"] = n.MainLogPath
	n.fieldMap["last_modified"] = n.LastModified
	n.fieldMap["last_size"] = n.LastSize
	n.fieldMap["last_position"] = n.LastPosition
	n.fieldMap["last_indexed"] = n.LastIndexed
	n.fieldMap["index_start_time"] = n.IndexStartTime
	n.fieldMap["index_duration"] = n.IndexDuration
	n.fieldMap["time_range_start"] = n.TimeRangeStart
	n.fieldMap["time_range_end"] = n.TimeRangeEnd
	n.fieldMap["document_count"] = n.DocumentCount
	n.fieldMap["enabled"] = n.Enabled
	n.fieldMap["index_status"] = n.IndexStatus
	n.fieldMap["error_message"] = n.ErrorMessage
	n.fieldMap["error_time"] = n.ErrorTime
	n.fieldMap["retry_count"] = n.RetryCount
	n.fieldMap["queue_position"] = n.QueuePosition
}

func (n nginxLogIndex) clone(db *gorm.DB) nginxLogIndex {
	n.nginxLogIndexDo.ReplaceConnPool(db.Statement.ConnPool)
	return n
}

func (n nginxLogIndex) replaceDB(db *gorm.DB) nginxLogIndex {
	n.nginxLogIndexDo.ReplaceDB(db)
	return n
}

type nginxLogIndexDo struct{ gen.DO }

// FirstByID Where("id=@id")
func (n nginxLogIndexDo) FirstByID(id uint64) (result *model.NginxLogIndex, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, id)
	generateSQL.WriteString("id=? ")

	var executeSQL *gorm.DB
	executeSQL = n.UnderlyingDB().Where(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// DeleteByID update @@table set deleted_at=strftime('%Y-%m-%d %H:%M:%S','now') where id=@id
func (n nginxLogIndexDo) DeleteByID(id uint64) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, id)
	generateSQL.WriteString("update nginx_log_indices set deleted_at=strftime('%Y-%m-%d %H:%M:%S','now') where id=? ")

	var executeSQL *gorm.DB
	executeSQL = n.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (n nginxLogIndexDo) Debug() *nginxLogIndexDo {
	return n.withDO(n.DO.Debug())
}

func (n nginxLogIndexDo) WithContext(ctx context.Context) *nginxLogIndexDo {
	return n.withDO(n.DO.WithContext(ctx))
}

func (n nginxLogIndexDo) ReadDB() *nginxLogIndexDo {
	return n.Clauses(dbresolver.Read)
}

func (n nginxLogIndexDo) WriteDB() *nginxLogIndexDo {
	return n.Clauses(dbresolver.Write)
}

func (n nginxLogIndexDo) Session(config *gorm.Session) *nginxLogIndexDo {
	return n.withDO(n.DO.Session(config))
}

func (n nginxLogIndexDo) Clauses(conds ...clause.Expression) *nginxLogIndexDo {
	return n.withDO(n.DO.Clauses(conds...))
}

func (n nginxLogIndexDo) Returning(value interface{}, columns ...string) *nginxLogIndexDo {
	return n.withDO(n.DO.Returning(value, columns...))
}

func (n nginxLogIndexDo) Not(conds ...gen.Condition) *nginxLogIndexDo {
	return n.withDO(n.DO.Not(conds...))
}

func (n nginxLogIndexDo) Or(conds ...gen.Condition) *nginxLogIndexDo {
	return n.withDO(n.DO.Or(conds...))
}

func (n nginxLogIndexDo) Select(conds ...field.Expr) *nginxLogIndexDo {
	return n.withDO(n.DO.Select(conds...))
}

func (n nginxLogIndexDo) Where(conds ...gen.Condition) *nginxLogIndexDo {
	return n.withDO(n.DO.Where(conds...))
}

func (n nginxLogIndexDo) Order(conds ...field.Expr) *nginxLogIndexDo {
	return n.withDO(n.DO.Order(conds...))
}

func (n nginxLogIndexDo) Distinct(cols ...field.Expr) *nginxLogIndexDo {
	return n.withDO(n.DO.Distinct(cols...))
}

func (n nginxLogIndexDo) Omit(cols ...field.Expr) *nginxLogIndexDo {
	return n.withDO(n.DO.Omit(cols...))
}

func (n nginxLogIndexDo) Join(table schema.Tabler, on ...field.Expr) *nginxLogIndexDo {
	return n.withDO(n.DO.Join(table, on...))
}

func (n nginxLogIndexDo) LeftJoin(table schema.Tabler, on ...field.Expr) *nginxLogIndexDo {
	return n.withDO(n.DO.LeftJoin(table, on...))
}

func (n nginxLogIndexDo) RightJoin(table schema.Tabler, on ...field.Expr) *nginxLogIndexDo {
	return n.withDO(n.DO.RightJoin(table, on...))
}

func (n nginxLogIndexDo) Group(cols ...field.Expr) *nginxLogIndexDo {
	return n.withDO(n.DO.Group(cols...))
}

func (n nginxLogIndexDo) Having(conds ...gen.Condition) *nginxLogIndexDo {
	return n.withDO(n.DO.Having(conds...))
}

func (n nginxLogIndexDo) Limit(limit int) *nginxLogIndexDo {
	return n.withDO(n.DO.Limit(limit))
}

func (n nginxLogIndexDo) Offset(offset int) *nginxLogIndexDo {
	return n.withDO(n.DO.Offset(offset))
}

func (n nginxLogIndexDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *nginxLogIndexDo {
	return n.withDO(n.DO.Scopes(funcs...))
}

func (n nginxLogIndexDo) Unscoped() *nginxLogIndexDo {
	return n.withDO(n.DO.Unscoped())
}

func (n nginxLogIndexDo) Create(values ...*model.NginxLogIndex) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Create(values)
}

func (n nginxLogIndexDo) CreateInBatches(values []*model.NginxLogIndex, batchSize int) error {
	return n.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (n nginxLogIndexDo) Save(values ...*model.NginxLogIndex) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Save(values)
}

func (n nginxLogIndexDo) First() (*model.NginxLogIndex, error) {
	if result, err := n.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.NginxLogIndex), nil
	}
}

func (n nginxLogIndexDo) Take() (*model.NginxLogIndex, error) {
	if result, err := n.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.NginxLogIndex), nil
	}
}

func (n nginxLogIndexDo) Last() (*model.NginxLogIndex, error) {
	if result, err := n.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.NginxLogIndex), nil
	}
}

func (n nginxLogIndexDo) Find() ([]*model.NginxLogIndex, error) {
	result, err := n.DO.Find()
	return result.([]*model.NginxLogIndex), err
}

func (n nginxLogIndexDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.NginxLogIndex, err error) {
	buf := make([]*model.NginxLogIndex, 0, batchSize)
	err = n.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (n nginxLogIndexDo) FindInBatches(result *[]*model.NginxLogIndex, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return n.DO.FindInBatches(result, batchSize, fc)
}

func (n nginxLogIndexDo) Attrs(attrs ...field.AssignExpr) *nginxLogIndexDo {
	return n.withDO(n.DO.Attrs(attrs...))
}

func (n nginxLogIndexDo) Assign(attrs ...field.AssignExpr) *nginxLogIndexDo {
	return n.withDO(n.DO.Assign(attrs...))
}

func (n nginxLogIndexDo) Joins(fields ...field.RelationField) *nginxLogIndexDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Joins(_f))
	}
	return &n
}

func (n nginxLogIndexDo) Preload(fields ...field.RelationField) *nginxLogIndexDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Preload(_f))
	}
	return &n
}

func (n nginxLogIndexDo) FirstOrInit() (*model.NginxLogIndex, error) {
	if result, err := n.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.NginxLogIndex), nil
	}
}

func (n nginxLogIndexDo) FirstOrCreate() (*model.NginxLogIndex, error) {
	if result, err := n.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.NginxLogIndex), nil
	}
}

func (n nginxLogIndexDo) FindByPage(offset int, limit int) (result []*model.NginxLogIndex, count int64, err error) {
	result, err = n.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = n.Offset(-1).Limit(-1).Count()
	return
}

func (n nginxLogIndexDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = n.Count()
	if err != nil {
		return
	}

	err = n.Offset(offset).Limit(limit).Scan(result)
	return
}

func (n nginxLogIndexDo) Scan(result interface{}) (err error) {
	return n.DO.Scan(result)
}

func (n nginxLogIndexDo) Delete(models ...*model.NginxLogIndex) (result gen.ResultInfo, err error) {
	return n.DO.Delete(models)
}

func (n *nginxLogIndexDo) withDO(do gen.Dao) *nginxLogIndexDo {
	n.DO = *do.(*gen.DO)
	return n
}
