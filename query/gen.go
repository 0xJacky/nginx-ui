// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"

	"gorm.io/gen"

	"gorm.io/plugin/dbresolver"
)

var (
	Q              = new(Query)
	AcmeUser       *acmeUser
	AuthToken      *authToken
	AutoBackup     *autoBackup
	BanIP          *banIP
	Cert           *cert
	Config         *config
	ConfigBackup   *configBackup
	DnsCredential  *dnsCredential
	ExternalNotify *externalNotify
	LLMMessages    *lLMMessages
	Namespace      *namespace
	NginxLogIndex  *nginxLogIndex
	Node           *node
	Notification   *notification
	Passkey        *passkey
	Site           *site
	SiteConfig     *siteConfig
	Stream         *stream
	User           *user
)

func SetDefault(db *gorm.DB, opts ...gen.DOOption) {
	*Q = *Use(db, opts...)
	AcmeUser = &Q.AcmeUser
	AuthToken = &Q.AuthToken
	AutoBackup = &Q.AutoBackup
	BanIP = &Q.BanIP
	Cert = &Q.Cert
	Config = &Q.Config
	ConfigBackup = &Q.ConfigBackup
	DnsCredential = &Q.DnsCredential
	ExternalNotify = &Q.ExternalNotify
	LLMMessages = &Q.LLMMessages
	Namespace = &Q.Namespace
	NginxLogIndex = &Q.NginxLogIndex
	Node = &Q.Node
	Notification = &Q.Notification
	Passkey = &Q.Passkey
	Site = &Q.Site
	SiteConfig = &Q.SiteConfig
	Stream = &Q.Stream
	User = &Q.User
}

func Use(db *gorm.DB, opts ...gen.DOOption) *Query {
	return &Query{
		db:             db,
		AcmeUser:       newAcmeUser(db, opts...),
		AuthToken:      newAuthToken(db, opts...),
		AutoBackup:     newAutoBackup(db, opts...),
		BanIP:          newBanIP(db, opts...),
		Cert:           newCert(db, opts...),
		Config:         newConfig(db, opts...),
		ConfigBackup:   newConfigBackup(db, opts...),
		DnsCredential:  newDnsCredential(db, opts...),
		ExternalNotify: newExternalNotify(db, opts...),
		LLMMessages:    newLLMMessages(db, opts...),
		Namespace:      newNamespace(db, opts...),
		NginxLogIndex:  newNginxLogIndex(db, opts...),
		Node:           newNode(db, opts...),
		Notification:   newNotification(db, opts...),
		Passkey:        newPasskey(db, opts...),
		Site:           newSite(db, opts...),
		SiteConfig:     newSiteConfig(db, opts...),
		Stream:         newStream(db, opts...),
		User:           newUser(db, opts...),
	}
}

type Query struct {
	db *gorm.DB

	AcmeUser       acmeUser
	AuthToken      authToken
	AutoBackup     autoBackup
	BanIP          banIP
	Cert           cert
	Config         config
	ConfigBackup   configBackup
	DnsCredential  dnsCredential
	ExternalNotify externalNotify
	LLMMessages    lLMMessages
	Namespace      namespace
	NginxLogIndex  nginxLogIndex
	Node           node
	Notification   notification
	Passkey        passkey
	Site           site
	SiteConfig     siteConfig
	Stream         stream
	User           user
}

func (q *Query) Available() bool { return q.db != nil }

func (q *Query) clone(db *gorm.DB) *Query {
	return &Query{
		db:             db,
		AcmeUser:       q.AcmeUser.clone(db),
		AuthToken:      q.AuthToken.clone(db),
		AutoBackup:     q.AutoBackup.clone(db),
		BanIP:          q.BanIP.clone(db),
		Cert:           q.Cert.clone(db),
		Config:         q.Config.clone(db),
		ConfigBackup:   q.ConfigBackup.clone(db),
		DnsCredential:  q.DnsCredential.clone(db),
		ExternalNotify: q.ExternalNotify.clone(db),
		LLMMessages:    q.LLMMessages.clone(db),
		Namespace:      q.Namespace.clone(db),
		NginxLogIndex:  q.NginxLogIndex.clone(db),
		Node:           q.Node.clone(db),
		Notification:   q.Notification.clone(db),
		Passkey:        q.Passkey.clone(db),
		Site:           q.Site.clone(db),
		SiteConfig:     q.SiteConfig.clone(db),
		Stream:         q.Stream.clone(db),
		User:           q.User.clone(db),
	}
}

func (q *Query) ReadDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Read))
}

func (q *Query) WriteDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Write))
}

func (q *Query) ReplaceDB(db *gorm.DB) *Query {
	return &Query{
		db:             db,
		AcmeUser:       q.AcmeUser.replaceDB(db),
		AuthToken:      q.AuthToken.replaceDB(db),
		AutoBackup:     q.AutoBackup.replaceDB(db),
		BanIP:          q.BanIP.replaceDB(db),
		Cert:           q.Cert.replaceDB(db),
		Config:         q.Config.replaceDB(db),
		ConfigBackup:   q.ConfigBackup.replaceDB(db),
		DnsCredential:  q.DnsCredential.replaceDB(db),
		ExternalNotify: q.ExternalNotify.replaceDB(db),
		LLMMessages:    q.LLMMessages.replaceDB(db),
		Namespace:      q.Namespace.replaceDB(db),
		NginxLogIndex:  q.NginxLogIndex.replaceDB(db),
		Node:           q.Node.replaceDB(db),
		Notification:   q.Notification.replaceDB(db),
		Passkey:        q.Passkey.replaceDB(db),
		Site:           q.Site.replaceDB(db),
		SiteConfig:     q.SiteConfig.replaceDB(db),
		Stream:         q.Stream.replaceDB(db),
		User:           q.User.replaceDB(db),
	}
}

type queryCtx struct {
	AcmeUser       *acmeUserDo
	AuthToken      *authTokenDo
	AutoBackup     *autoBackupDo
	BanIP          *banIPDo
	Cert           *certDo
	Config         *configDo
	ConfigBackup   *configBackupDo
	DnsCredential  *dnsCredentialDo
	ExternalNotify *externalNotifyDo
	LLMMessages    *lLMMessagesDo
	Namespace      *namespaceDo
	NginxLogIndex  *nginxLogIndexDo
	Node           *nodeDo
	Notification   *notificationDo
	Passkey        *passkeyDo
	Site           *siteDo
	SiteConfig     *siteConfigDo
	Stream         *streamDo
	User           *userDo
}

func (q *Query) WithContext(ctx context.Context) *queryCtx {
	return &queryCtx{
		AcmeUser:       q.AcmeUser.WithContext(ctx),
		AuthToken:      q.AuthToken.WithContext(ctx),
		AutoBackup:     q.AutoBackup.WithContext(ctx),
		BanIP:          q.BanIP.WithContext(ctx),
		Cert:           q.Cert.WithContext(ctx),
		Config:         q.Config.WithContext(ctx),
		ConfigBackup:   q.ConfigBackup.WithContext(ctx),
		DnsCredential:  q.DnsCredential.WithContext(ctx),
		ExternalNotify: q.ExternalNotify.WithContext(ctx),
		LLMMessages:    q.LLMMessages.WithContext(ctx),
		Namespace:      q.Namespace.WithContext(ctx),
		NginxLogIndex:  q.NginxLogIndex.WithContext(ctx),
		Node:           q.Node.WithContext(ctx),
		Notification:   q.Notification.WithContext(ctx),
		Passkey:        q.Passkey.WithContext(ctx),
		Site:           q.Site.WithContext(ctx),
		SiteConfig:     q.SiteConfig.WithContext(ctx),
		Stream:         q.Stream.WithContext(ctx),
		User:           q.User.WithContext(ctx),
	}
}

func (q *Query) Transaction(fc func(tx *Query) error, opts ...*sql.TxOptions) error {
	return q.db.Transaction(func(tx *gorm.DB) error { return fc(q.clone(tx)) }, opts...)
}

func (q *Query) Begin(opts ...*sql.TxOptions) *QueryTx {
	tx := q.db.Begin(opts...)
	return &QueryTx{Query: q.clone(tx), Error: tx.Error}
}

type QueryTx struct {
	*Query
	Error error
}

func (q *QueryTx) Commit() error {
	return q.db.Commit().Error
}

func (q *QueryTx) Rollback() error {
	return q.db.Rollback().Error
}

func (q *QueryTx) SavePoint(name string) error {
	return q.db.SavePoint(name).Error
}

func (q *QueryTx) RollbackTo(name string) error {
	return q.db.RollbackTo(name).Error
}
